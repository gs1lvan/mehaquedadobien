<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de Integraci√≥n Completa - Recetario Personal</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .test-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        .test-section h2 {
            color: #495057;
            margin-top: 0;
            font-size: 1.3rem;
        }
        .test-case {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        .test-case h3 {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            color: #333;
        }
        .test-status {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-right: 10px;
        }
        .test-status.pending {
            background: #ffc107;
            color: #856404;
        }
        .test-status.running {
            background: #17a2b8;
            color: white;
        }
        .test-status.passed {
            background: #28a745;
            color: white;
        }
        .test-status.failed {
            background: #dc3545;
            color: white;
        }
        .test-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        .test-result.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-result.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-result.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .test-actions {
            margin-top: 20px;
            text-align: center;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 500;
            margin: 5px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.3);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .summary {
            margin-top: 30px;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 10px;
            border-left: 4px solid #2196f3;
        }
        .summary h2 {
            margin-top: 0;
            color: #1976d2;
        }
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .summary-stat {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
        .summary-stat .number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }
        .summary-stat .label {
            font-size: 0.9rem;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ Test de Integraci√≥n Completa</h1>
        <p style="text-align: center; color: #6c757d; margin-bottom: 30px;">
            Prueba exhaustiva de todas las funcionalidades del Recetario Personal
        </p>

        <div class="test-actions">
            <button class="btn" id="run-all-tests">‚ñ∂Ô∏è Ejecutar Todos los Tests</button>
            <button class="btn" id="clear-storage">üóëÔ∏è Limpiar Almacenamiento</button>
        </div>

        <!-- Test Section 1: Create Recipe Flow -->
        <div class="test-section">
            <h2>1Ô∏è‚É£ Flujo Completo de Creaci√≥n de Recetas</h2>
            <div class="test-case" id="test-create-recipe">
                <h3>Test: Crear receta completa con todos los datos</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 2: Edit Recipe Flow -->
        <div class="test-section">
            <h2>2Ô∏è‚É£ Flujo de Edici√≥n de Recetas</h2>
            <div class="test-case" id="test-edit-recipe">
                <h3>Test: Editar receta existente</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 3: Duplicate Recipe Flow -->
        <div class="test-section">
            <h2>3Ô∏è‚É£ Flujo de Duplicaci√≥n de Recetas</h2>
            <div class="test-case" id="test-duplicate-recipe">
                <h3>Test: Duplicar receta con todos los datos</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 4: Delete Recipe Flow -->
        <div class="test-section">
            <h2>4Ô∏è‚É£ Flujo de Eliminaci√≥n de Recetas</h2>
            <div class="test-case" id="test-delete-recipe">
                <h3>Test: Eliminar receta</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 5: Data Persistence -->
        <div class="test-section">
            <h2>5Ô∏è‚É£ Persistencia de Datos</h2>
            <div class="test-case" id="test-persistence">
                <h3>Test: Verificar persistencia al recargar</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 6: Filtering -->
        <div class="test-section">
            <h2>6Ô∏è‚É£ Filtrado de Recetas</h2>
            <div class="test-case" id="test-filtering">
                <h3>Test: Filtrar por diferentes categor√≠as</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 7: XML Export -->
        <div class="test-section">
            <h2>7Ô∏è‚É£ Exportaci√≥n XML</h2>
            <div class="test-case" id="test-xml-export">
                <h3>Test: Exportar receta a XML</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 8: PDF Export -->
        <div class="test-section">
            <h2>8Ô∏è‚É£ Exportaci√≥n PDF</h2>
            <div class="test-case" id="test-pdf-export">
                <h3>Test: Exportar receta a PDF</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 9: Offline Functionality -->
        <div class="test-section">
            <h2>9Ô∏è‚É£ Funcionalidad Offline</h2>
            <div class="test-case" id="test-offline">
                <h3>Test: Verificar funcionalidad sin conexi√≥n</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Test Section 10: Responsive Design -->
        <div class="test-section">
            <h2>üîü Dise√±o Responsive</h2>
            <div class="test-case" id="test-responsive">
                <h3>Test: Verificar responsive en diferentes tama√±os</h3>
                <span class="test-status pending">Pendiente</span>
                <div class="test-result"></div>
            </div>
        </div>

        <!-- Summary Section -->
        <div class="summary" id="test-summary" style="display: none;">
            <h2>üìä Resumen de Resultados</h2>
            <div class="summary-stats">
                <div class="summary-stat">
                    <span class="number" id="total-tests">0</span>
                    <span class="label">Total Tests</span>
                </div>
                <div class="summary-stat">
                    <span class="number" style="color: #28a745;" id="passed-tests">0</span>
                    <span class="label">Pasados</span>
                </div>
                <div class="summary-stat">
                    <span class="number" style="color: #dc3545;" id="failed-tests">0</span>
                    <span class="label">Fallidos</span>
                </div>
                <div class="summary-stat">
                    <span class="number" style="color: #667eea;" id="success-rate">0%</span>
                    <span class="label">Tasa de √âxito</span>
                </div>
            </div>
        </div>
    </div>

    <script src="models.js"></script>
    <script>
        // Test utilities
        const TestUtils = {
            updateStatus(testId, status) {
                const testCase = document.getElementById(testId);
                const statusElement = testCase.querySelector('.test-status');
                statusElement.className = `test-status ${status}`;
                statusElement.textContent = {
                    'pending': 'Pendiente',
                    'running': 'Ejecutando...',
                    'passed': '‚úì Pasado',
                    'failed': '‚úó Fallido'
                }[status];
            },

            showResult(testId, type, message) {
                const testCase = document.getElementById(testId);
                const resultElement = testCase.querySelector('.test-result');
                resultElement.className = `test-result ${type}`;
                resultElement.innerHTML = message;
            },

            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            generateTestImage() {
                // Create a small test image (1x1 pixel red PNG)
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(0, 0, 100, 100);
                return canvas.toDataURL('image/png');
            },

            createTestRecipe(name = 'Receta de Prueba') {
                return {
                    name: name,
                    category: 'carne',
                    preparationMethod: 'M√©todo de preparaci√≥n de prueba. Paso 1: Preparar ingredientes. Paso 2: Cocinar.',
                    ingredients: [
                        new Ingredient({ name: 'Pollo', quantity: 500, unit: 'g', order: 0 }),
                        new Ingredient({ name: 'Sal', quantity: 1, unit: 'cucharadita', order: 1 }),
                        new Ingredient({ name: 'Aceite', quantity: 2, unit: 'cucharada', order: 2 })
                    ],
                    additionSequences: [
                        new Sequence({ step: 1, ingredientIds: [], description: 'A√±adir pollo primero' }),
                        new Sequence({ step: 2, ingredientIds: [], description: 'A√±adir sal y aceite' })
                    ],
                    images: [
                        new MediaFile({
                            name: 'test-image.png',
                            type: 'image/png',
                            data: this.generateTestImage(),
                            size: 1000
                        })
                    ],
                    videos: []
                };
            }
        };

        // Test implementations
        const Tests = {
            async testCreateRecipe() {
                const testId = 'test-create-recipe';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    // Initialize storage
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Create test recipe
                    const recipeData = TestUtils.createTestRecipe('Pollo al Horno');
                    const recipe = new Recipe(recipeData);
                    
                    // Save recipe
                    const recipeId = await storage.saveRecipe(recipe);
                    
                    // Verify saved
                    const savedRecipe = await storage.getRecipe(recipeId);
                    
                    if (!savedRecipe) {
                        throw new Error('La receta no se guard√≥ correctamente');
                    }
                    
                    if (savedRecipe.name !== 'Pollo al Horno') {
                        throw new Error('El nombre de la receta no coincide');
                    }
                    
                    if (savedRecipe.ingredients.length !== 3) {
                        throw new Error('Los ingredientes no se guardaron correctamente');
                    }
                    
                    if (savedRecipe.additionSequences.length !== 2) {
                        throw new Error('Las secuencias no se guardaron correctamente');
                    }
                    
                    if (savedRecipe.images.length !== 1) {
                        throw new Error('Las im√°genes no se guardaron correctamente');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Receta creada exitosamente<br>
                        - ID: ${recipeId}<br>
                        - Nombre: ${savedRecipe.name}<br>
                        - Ingredientes: ${savedRecipe.ingredients.length}<br>
                        - Secuencias: ${savedRecipe.additionSequences.length}<br>
                        - Im√°genes: ${savedRecipe.images.length}`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testEditRecipe() {
                const testId = 'test-edit-recipe';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Create initial recipe
                    const recipeData = TestUtils.createTestRecipe('Receta Original');
                    const recipe = new Recipe(recipeData);
                    const recipeId = await storage.saveRecipe(recipe);
                    
                    await TestUtils.sleep(100);
                    
                    // Edit recipe
                    const savedRecipe = await storage.getRecipe(recipeId);
                    savedRecipe.name = 'Receta Editada';
                    savedRecipe.category = 'pescado';
                    savedRecipe.preparationMethod = 'M√©todo actualizado';
                    savedRecipe.updatedAt = new Date();
                    
                    await storage.saveRecipe(savedRecipe);
                    
                    // Verify changes
                    const editedRecipe = await storage.getRecipe(recipeId);
                    
                    if (editedRecipe.name !== 'Receta Editada') {
                        throw new Error('El nombre no se actualiz√≥');
                    }
                    
                    if (editedRecipe.category !== 'pescado') {
                        throw new Error('La categor√≠a no se actualiz√≥');
                    }
                    
                    if (editedRecipe.id !== recipeId) {
                        throw new Error('El ID cambi√≥ durante la edici√≥n');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Receta editada exitosamente<br>
                        - ID mantenido: ${recipeId}<br>
                        - Nombre actualizado: ${editedRecipe.name}<br>
                        - Categor√≠a actualizada: ${editedRecipe.category}<br>
                        - M√©todo actualizado: ${editedRecipe.preparationMethod.substring(0, 30)}...`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testDuplicateRecipe() {
                const testId = 'test-duplicate-recipe';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Create original recipe
                    const recipeData = TestUtils.createTestRecipe('Receta Original');
                    const originalRecipe = new Recipe(recipeData);
                    const originalId = await storage.saveRecipe(originalRecipe);
                    
                    // Duplicate recipe
                    const duplicateData = {
                        ...recipeData,
                        name: recipeData.name + ' (Copia)',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    const duplicateRecipe = new Recipe(duplicateData);
                    const duplicateId = await storage.saveRecipe(duplicateRecipe);
                    
                    // Verify duplicate
                    const savedDuplicate = await storage.getRecipe(duplicateId);
                    
                    if (savedDuplicate.id === originalId) {
                        throw new Error('El duplicado tiene el mismo ID que el original');
                    }
                    
                    if (!savedDuplicate.name.includes('(Copia)')) {
                        throw new Error('El nombre del duplicado no incluye "(Copia)"');
                    }
                    
                    if (savedDuplicate.ingredients.length !== originalRecipe.ingredients.length) {
                        throw new Error('Los ingredientes no se copiaron correctamente');
                    }
                    
                    if (savedDuplicate.additionSequences.length !== originalRecipe.additionSequences.length) {
                        throw new Error('Las secuencias no se copiaron correctamente');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Receta duplicada exitosamente<br>
                        - ID original: ${originalId}<br>
                        - ID duplicado: ${duplicateId}<br>
                        - Nombre: ${savedDuplicate.name}<br>
                        - Ingredientes copiados: ${savedDuplicate.ingredients.length}<br>
                        - Secuencias copiadas: ${savedDuplicate.additionSequences.length}`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testDeleteRecipe() {
                const testId = 'test-delete-recipe';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Create recipe
                    const recipeData = TestUtils.createTestRecipe('Receta a Eliminar');
                    const recipe = new Recipe(recipeData);
                    const recipeId = await storage.saveRecipe(recipe);
                    
                    // Verify it exists
                    let savedRecipe = await storage.getRecipe(recipeId);
                    if (!savedRecipe) {
                        throw new Error('La receta no se guard√≥ antes de eliminar');
                    }
                    
                    // Delete recipe
                    await storage.deleteRecipe(recipeId);
                    
                    // Verify it's deleted
                    savedRecipe = await storage.getRecipe(recipeId);
                    if (savedRecipe) {
                        throw new Error('La receta no se elimin√≥ correctamente');
                    }
                    
                    // Verify it's not in the list
                    const allRecipes = await storage.getAllRecipes();
                    const foundRecipe = allRecipes.find(r => r.id === recipeId);
                    if (foundRecipe) {
                        throw new Error('La receta eliminada a√∫n aparece en la lista');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Receta eliminada exitosamente<br>
                        - ID eliminado: ${recipeId}<br>
                        - Verificado que no existe en la base de datos<br>
                        - Verificado que no aparece en la lista de recetas`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testPersistence() {
                const testId = 'test-persistence';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Create multiple recipes
                    const recipe1 = new Recipe(TestUtils.createTestRecipe('Receta 1'));
                    const recipe2 = new Recipe(TestUtils.createTestRecipe('Receta 2'));
                    const recipe3 = new Recipe(TestUtils.createTestRecipe('Receta 3'));
                    
                    await storage.saveRecipe(recipe1);
                    await storage.saveRecipe(recipe2);
                    await storage.saveRecipe(recipe3);
                    
                    // Simulate reload by creating new storage instance
                    const newStorage = new StorageManager();
                    await newStorage.initDB();
                    
                    // Load all recipes
                    const loadedRecipes = await newStorage.getAllRecipes();
                    
                    if (loadedRecipes.length < 3) {
                        throw new Error(`Solo se cargaron ${loadedRecipes.length} de 3 recetas`);
                    }
                    
                    // Verify data integrity
                    const recipe1Loaded = loadedRecipes.find(r => r.name === 'Receta 1');
                    if (!recipe1Loaded) {
                        throw new Error('Receta 1 no se encontr√≥ despu√©s de recargar');
                    }
                    
                    if (recipe1Loaded.ingredients.length !== 3) {
                        throw new Error('Los ingredientes no persistieron correctamente');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Persistencia verificada exitosamente<br>
                        - Recetas guardadas: 3<br>
                        - Recetas cargadas: ${loadedRecipes.length}<br>
                        - Integridad de datos: ‚úì<br>
                        - Ingredientes persistidos: ‚úì<br>
                        - Secuencias persistidas: ‚úì`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testFiltering() {
                const testId = 'test-filtering';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Clear existing recipes
                    await storage.clearAllRecipes();
                    
                    // Create recipes with different categories
                    const carneRecipe = new Recipe({...TestUtils.createTestRecipe('Pollo'), category: 'carne'});
                    const pescadoRecipe = new Recipe({...TestUtils.createTestRecipe('Salm√≥n'), category: 'pescado'});
                    const verduraRecipe = new Recipe({...TestUtils.createTestRecipe('Ensalada'), category: 'verdura'});
                    const sinCategoriaRecipe = new Recipe({...TestUtils.createTestRecipe('Postre'), category: null});
                    
                    await storage.saveRecipe(carneRecipe);
                    await storage.saveRecipe(pescadoRecipe);
                    await storage.saveRecipe(verduraRecipe);
                    await storage.saveRecipe(sinCategoriaRecipe);
                    
                    // Test filtering
                    const allRecipes = await storage.getAllRecipes();
                    
                    const carneRecipes = allRecipes.filter(r => r.category === 'carne');
                    const pescadoRecipes = allRecipes.filter(r => r.category === 'pescado');
                    const verduraRecipes = allRecipes.filter(r => r.category === 'verdura');
                    const sinCategoriaRecipes = allRecipes.filter(r => r.category === null);
                    
                    if (carneRecipes.length !== 1) {
                        throw new Error(`Filtro de carne fall√≥: esperado 1, obtenido ${carneRecipes.length}`);
                    }
                    
                    if (pescadoRecipes.length !== 1) {
                        throw new Error(`Filtro de pescado fall√≥: esperado 1, obtenido ${pescadoRecipes.length}`);
                    }
                    
                    if (verduraRecipes.length !== 1) {
                        throw new Error(`Filtro de verdura fall√≥: esperado 1, obtenido ${verduraRecipes.length}`);
                    }
                    
                    if (sinCategoriaRecipes.length !== 1) {
                        throw new Error(`Filtro sin categor√≠a fall√≥: esperado 1, obtenido ${sinCategoriaRecipes.length}`);
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Filtrado verificado exitosamente<br>
                        - Total recetas: ${allRecipes.length}<br>
                        - Carne: ${carneRecipes.length}<br>
                        - Pescado: ${pescadoRecipes.length}<br>
                        - Verdura: ${verduraRecipes.length}<br>
                        - Sin categor√≠a: ${sinCategoriaRecipes.length}`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testXMLExport() {
                const testId = 'test-xml-export';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    // Create test recipe
                    const recipeData = TestUtils.createTestRecipe('Receta para XML');
                    const recipe = new Recipe(recipeData);
                    
                    // Generate XML
                    const xml = XMLExporter.generateXML(recipe);
                    
                    if (!xml || xml.length === 0) {
                        throw new Error('XML generado est√° vac√≠o');
                    }
                    
                    // Verify XML structure
                    if (!xml.includes('<recipe>')) {
                        throw new Error('XML no contiene elemento ra√≠z <recipe>');
                    }
                    
                    if (!xml.includes('<name>')) {
                        throw new Error('XML no contiene elemento <name>');
                    }
                    
                    if (!xml.includes('<ingredients>')) {
                        throw new Error('XML no contiene elemento <ingredients>');
                    }
                    
                    if (!xml.includes('Receta para XML')) {
                        throw new Error('XML no contiene el nombre de la receta');
                    }
                    
                    // Parse XML to verify it's valid
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xml, 'text/xml');
                    const parseError = xmlDoc.querySelector('parsererror');
                    
                    if (parseError) {
                        throw new Error('XML generado no es v√°lido: ' + parseError.textContent);
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Exportaci√≥n XML exitosa<br>
                        - Tama√±o XML: ${xml.length} caracteres<br>
                        - Estructura v√°lida: ‚úì<br>
                        - Contiene nombre: ‚úì<br>
                        - Contiene ingredientes: ‚úì<br>
                        - XML bien formado: ‚úì`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testPDFExport() {
                const testId = 'test-pdf-export';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    // Check if jsPDF is available
                    if (typeof window.jspdf === 'undefined') {
                        throw new Error('jsPDF no est√° cargado');
                    }
                    
                    // Create test recipe
                    const recipeData = TestUtils.createTestRecipe('Receta para PDF');
                    const recipe = new Recipe(recipeData);
                    
                    // Generate PDF
                    const pdf = PDFExporter.generatePDF(recipe);
                    
                    if (!pdf) {
                        throw new Error('PDF no se gener√≥');
                    }
                    
                    // Verify PDF has content
                    const pdfOutput = pdf.output('datauristring');
                    
                    if (!pdfOutput || pdfOutput.length === 0) {
                        throw new Error('PDF generado est√° vac√≠o');
                    }
                    
                    if (!pdfOutput.startsWith('data:application/pdf')) {
                        throw new Error('PDF no tiene el formato correcto');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Exportaci√≥n PDF exitosa<br>
                        - PDF generado: ‚úì<br>
                        - Formato v√°lido: ‚úì<br>
                        - Tama√±o: ${(pdfOutput.length / 1024).toFixed(2)} KB<br>
                        - Contiene datos: ‚úì`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testOffline() {
                const testId = 'test-offline';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    // Check if service worker is registered
                    if (!('serviceWorker' in navigator)) {
                        throw new Error('Service Worker no est√° soportado en este navegador');
                    }
                    
                    // Check if IndexedDB is available (for offline storage)
                    if (!window.indexedDB) {
                        TestUtils.showResult(testId, 'info', 
                            `‚ö†Ô∏è IndexedDB no disponible, usando localStorage como fallback<br>
                            - Service Worker: ${navigator.serviceWorker ? '‚úì' : '‚úó'}<br>
                            - Almacenamiento offline: ‚úì (localStorage)`
                        );
                    }
                    
                    const storage = new StorageManager();
                    await storage.initDB();
                    
                    // Test that we can save and retrieve data
                    const testRecipe = new Recipe(TestUtils.createTestRecipe('Test Offline'));
                    const recipeId = await storage.saveRecipe(testRecipe);
                    const retrieved = await storage.getRecipe(recipeId);
                    
                    if (!retrieved) {
                        throw new Error('No se pudo recuperar la receta en modo offline');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Funcionalidad offline verificada<br>
                        - Service Worker: ${navigator.serviceWorker ? '‚úì Soportado' : '‚úó No soportado'}<br>
                        - IndexedDB: ${window.indexedDB ? '‚úì Disponible' : '‚úó No disponible'}<br>
                        - Almacenamiento: ${storage.useLocalStorageFallback ? 'localStorage' : 'IndexedDB'}<br>
                        - Guardar/Cargar: ‚úì`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            },

            async testResponsive() {
                const testId = 'test-responsive';
                TestUtils.updateStatus(testId, 'running');
                
                try {
                    // Get current viewport dimensions
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    // Determine device type
                    let deviceType = 'Desktop';
                    if (width < 768) {
                        deviceType = 'Mobile';
                    } else if (width >= 768 && width <= 1024) {
                        deviceType = 'Tablet';
                    }
                    
                    // Check if CSS is loaded
                    const testElement = document.createElement('div');
                    testElement.className = 'recipe-card';
                    document.body.appendChild(testElement);
                    const styles = window.getComputedStyle(testElement);
                    document.body.removeChild(testElement);
                    
                    if (!styles.borderRadius || styles.borderRadius === '0px') {
                        throw new Error('Los estilos CSS no est√°n cargados correctamente');
                    }
                    
                    TestUtils.updateStatus(testId, 'passed');
                    TestUtils.showResult(testId, 'success', 
                        `‚úì Dise√±o responsive verificado<br>
                        - Ancho de pantalla: ${width}px<br>
                        - Alto de pantalla: ${height}px<br>
                        - Tipo de dispositivo: ${deviceType}<br>
                        - CSS cargado: ‚úì<br>
                        - Estilos aplicados: ‚úì`
                    );
                    return true;
                } catch (error) {
                    TestUtils.updateStatus(testId, 'failed');
                    TestUtils.showResult(testId, 'error', `‚úó Error: ${error.message}`);
                    return false;
                }
            }
        };

        // Run all tests
        async function runAllTests() {
            const runButton = document.getElementById('run-all-tests');
            runButton.disabled = true;
            runButton.textContent = '‚è≥ Ejecutando tests...';
            
            const results = [];
            
            // Run each test
            results.push(await Tests.testCreateRecipe());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testEditRecipe());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testDuplicateRecipe());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testDeleteRecipe());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testPersistence());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testFiltering());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testXMLExport());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testPDFExport());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testOffline());
            await TestUtils.sleep(500);
            
            results.push(await Tests.testResponsive());
            
            // Calculate summary
            const total = results.length;
            const passed = results.filter(r => r === true).length;
            const failed = total - passed;
            const successRate = ((passed / total) * 100).toFixed(1);
            
            // Update summary
            document.getElementById('total-tests').textContent = total;
            document.getElementById('passed-tests').textContent = passed;
            document.getElementById('failed-tests').textContent = failed;
            document.getElementById('success-rate').textContent = successRate + '%';
            document.getElementById('test-summary').style.display = 'block';
            
            runButton.disabled = false;
            runButton.textContent = '‚ñ∂Ô∏è Ejecutar Todos los Tests';
            
            // Scroll to summary
            document.getElementById('test-summary').scrollIntoView({ behavior: 'smooth' });
        }

        // Clear storage
        async function clearStorage() {
            if (!confirm('¬øEst√°s seguro de que quieres limpiar todo el almacenamiento?')) {
                return;
            }
            
            try {
                const storage = new StorageManager();
                await storage.initDB();
                await storage.clearAllRecipes();
                alert('‚úì Almacenamiento limpiado exitosamente');
            } catch (error) {
                alert('‚úó Error al limpiar almacenamiento: ' + error.message);
            }
        }

        // Event listeners
        document.getElementById('run-all-tests').addEventListener('click', runAllTests);
        document.getElementById('clear-storage').addEventListener('click', clearStorage);
    </script>
</body>
</html>
